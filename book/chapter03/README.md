# Go의 동시성 구성 요소

## 고루틴

다른 코드와 함께 동시에 실행되는 함수이다 

OS스레드가 아니고 런타임에 의해 관리되는 스레드인 그린 스레드도 아니다 

코루틴이라고 불리는 더 높은 수준의 추상화이다.

단순히 동시에 실행되는 서브루틴(함수, 클로저, Go 메서드)으로서 비선점적으로 인터럽트할 수 없다 

고루틴은 잠시 중단 suspend 하거나 재진입 reentry 할 수 있는 여러 지점이 있다 



Go 런타임은 고루틴 실행 시 동작을 관찰해, 고루틴이 멈춰서 대기 block 중일 때 자동으로 일시 중단시키고 대기가 끝나면 다시 시작시킨다 

Go 런타임이 고루틴을 선점 가능하게 해주기는 하지만 고루틴이 멈춘 지점에서만 선점 가능하다 



고루틴을 호스팅하는 Go 메커니즘은 M:N 스케줄러를 구현한 굿으로 M개의 그린 스레드를 N개의 OS 스레드에 매핑한다는 것이다.

사용 가능한 그린 스레드보다 더 많은 고루틴이 있는 경우, 스케줄러는 사용 가능한 스레드들로 고루틴을 분배하고 이 고루틴들이 대기 상태가 되면 다른 고루틴이 실행될 수 있도록 한다 

  Go 는 fork-join 모델이라는 동시성 모델을 따른다 

자식 분기가 다시 부모 분기로 합쳐지는 지점을 합류 지점이라고 한다 

```go
var wg sync.WaitGroup
for _, situation := range []string{"hello", "hi", "good day"} {
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println(situation)
    }()
}
wg.Wait()
// good day
// good day
// good day
```

Go 런타임은 situation 변수에 대한 참조가 여전히 이루어져 고루틴이 계속 접근할 수 있도록 메모리를 힙으로 옮길 것이라는 사실을 알 수 있다 

고루틴이 실행되기 전에 루프가 종료되어 situation은 마지막 값은 good day에 대한 참조를 저장하고 있는 힙으로 옮겨지고 good day가 세 번 출력 된다 

```go
var wg sync.WaitGroup
for _, situation := range []string{"hello", "hi", "good day"} {
    wg.Add(1)
    go func() {
        defer wg.Done()
        fmt.Println(situation)
    }(situation)
}
wg.Wait()
// hello
// hi
// good day
```

여러 고루틴이 동일한 주소 공간에 대해 동작할 수 있기 때문에 여전히 동기화에 대해 걱정해야 한다. 

#### 컨텍스트 스위칭

컨텍스트 스위칭이란 동시에 실행되는 프로세스를 호스팅하는 어떤 것이 다른 동시 프로세스를 실행하도록 전환하기 위해 자신의 상태를 저장해야 하는 경우를 말한다 

동시에 실행되는 프로세스가 너무 많으면 프로세스 사이의 컨텍스트 스위칭에 모든 CPU 시간을 소ㅂ모하는라 실제 작업을 수행하지 못할 수 있다 

OS 수준에서 스레드를 사용하면 많은 비용이 발생할 수 있다 

OS 스레드는 레지스터 값이나 룩업 테이블, 메모리 맴 등을 저장해야만 시간이 됐을 때 현재 스레드로 다시 전환할 수 있다. 그런 다음 진입하는 스레드에 대해서도 동일한 정보를 로드해야 한다 

## sync 패키지

저수준의 메모리 접근 동기화에 가장 유용한 동시성 기본 요소들이 있다 

### WaitGroup

동시에 수행된 연산의 결과를 신경 쓰지 않거나, 결과를 수집할 다른 방법이 있는 경우 동시에 수행될 연산 집합을 기다릴 때 유용하다 

### Mutex와 RWMutex

상호 배제 mutual exclusion의 약자이다

임계 영역은 공유 리소스에 독점적으로 접근해야 하는 프로그램 영역을 말한다 

채널은 통신을 통해 메모리를 공유하는 반면 Mutex는 개밥ㄹ자가 메모리에 대한 접근을 동기화하기 위해 따라야 하는 규칙을 만들어 메모리를 공유한다

 RWMutex는 Mutex 보다 더 메모리를 제어할 수 있게 해준다. 일긱 잠금을 요청할 수 있지만 다른 프로세스가 쓰기 잠금을 가지고 있지 않은 경우에만 접근 권한이 부여된다. 

아무도 쓰기 잠금을 보유하고 있지 않다면 몇 개의 프로세스든 읽기 잠금을 보유할 수 있다. 

### Cond

- 고루틴들이 대기하거나, 어떤 이벤트의 발생을 알리는 집결 지점
- 이벤트란 두 개 이상의 고루틴 사이에서 어떤 사실이 발생했다는 사실 외에는 아무런 정보를 전달하지 않는 임의의 신호를 말한다.

### Once

sync.Once 가 Do에 전달된 각 함수가 호출된 회수가 아니라 Do 가 호출된 횟수만을 계산하기 때문이다 

#### 데드락 상황

```go
var onceA, onceB syncOnce
var initB func()
initA := func(){ onceB.Do(initB) }
initB = func() { onceA.Do(initA) }
onceA.Do(initA)
```



### Pool

동시에 실행해도 안전한 객체 풀 패턴의 구현이다 

높은 수준에서의 풀 패턴은 고정된 개수 만큼의 사용할 것들, 즉 풀을 생성해두고 활용할 수 있게하는 방법이다 

pool 활용해야하는지에 대해서는 조심해야 한다

Pool 을 사용하는 코드에서 서로 다른 객체가 필요한 경우 처음부터 인스턴스화 하는 작업보다 pool 에서 가져온 것을 변환하는 작업이 더 오래 걸릴 수 있다 

- sync.Pool 을 인스턴스화할 때, 호출 시 스레드로부터 안전한 New 멤버 변수를 전달한다
- Get에서 인스턴스를 받았을 때 돌려 받은 객체의 상태에 대한 가정을 해서는 안된다 
- Pool에서 꺼낸 객체로 작업을 마치면 반드시 Put을 호출한다 
- 그렇지 않으면 Pool은 아무 소용이 없고 defer 를 사용한다 
- 풀 안에 있는 개체들은 구조가 거의 균일해야 한다 



## 채널

채널의 두번째 리턴 값은 첫 번째 값이 프로레스 어딘가에서의 쓰기 연산을 통해 생성된 것인지 아니면 닫힌 채널에서 생성되는 기본값인지 나타내기 위해 사용된다 

닫힌 채널은 프로그램에서 더 이상 값이 채널을 통해 전송되지 않는다는 것을 나타낼 수 있기 때문에 매우 유용하다 

실제로 채널이 닫힌 상태에서도 계혹해서 채널에 대한 읽기 연산을 수행할 수 있다 

버퍼링된 채널은 특정 상황에서 유용하지만 유의해야 한다 

버퍼링된 채널은 성급한 최적화가 되는 경우가 많으며, 데드락이 발생하기 어렵게 만들어 데드락을 숨길 수 있다 

#### 채널을 명확하게 소유하는 고루틴과 채널의 대기 및 종료를 명확하게 처리하는 소비자

```go
chanOwner := func() <-chan int {
    resultStream := make(chan int, 5)
    go func() {
        defer close(resultStream)
        for i := 0; i <= 5; i++{
            resultStream <- i
        }
    }()
    return resultStream
}

resultStream := chanOwner()
for result := range resultStream {
    fmt.Printf("Received: %d\n", result)
}
fmt.Println("Done receiving!")
```

- resultStream 채널 생명주기가 chanOwner 함수 내에서 캡슐화 되는 방식이다 
- nil 채널이나 닫힌 채널에 대한 쓰기가 발생하지 않으며 닫기가 언제나 한 번만 발생한다는 사실이 분명하다 
- 프로그램에서 높은 리스크를 제거할 수 있고 채널 소유의 범위를 좁게 유지할 수 있도록 프로그램상에서 할 수 있는 일을 하는 것이 좋다 



## select 구문

더 큰 추상화를 형성하기 위해 프로그램에서 여러 채널을 함께 구성할 수 있는 방법이다 



